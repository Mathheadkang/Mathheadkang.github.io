<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ricci Flow Singularity Formation</title>
    <style>
        body { margin: 0; overflow: hidden; background: #ffffff; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 20px; left: 20px;
            background: rgba(255, 255, 255, 0.95); padding: 20px;
            border: 1px solid #ddd; border-radius: 8px;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            min-width: 200px;
        }
        h3 { margin: 0 0 10px 0; font-size: 18px; }
        .note { font-size: 13px; color: #555; margin-bottom: 15px; line-height: 1.4; }
        button {
            background: #222; color: white; border: none; padding: 12px 24px;
            font-size: 14px; cursor: pointer; border-radius: 4px; width: 100%;
            transition: background 0.2s;
        }
        button:hover { background: #444; }
        button:disabled { background: #bbb; cursor: default; }
        #status { margin-top: 10px; font-size: 12px; color: #444; text-align: center; height: 1.2em;}
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ccapture.js-npmfixed@1.1.0/build/CCapture.all.min.js"></script>
</head>
<body>

<div id="ui">
    <h3>Geometric Collapse</h3>
    <div class="note">
        Simulation of singularity formation:<br>
        1. Neck shrinks & shortens.<br>
        2. Torus moves to touch Sphere.<br>
        3. Topology collapses.
    </div>
    <button id="btn-record" onclick="startRecording()">Record WebM</button>
    <div id="status"></div>
</div>

<script>
    // --- SCENE SETUP ---
    const scene = new THREE.Scene();
    // Orthographic camera for a diagrammatic, distortion-free look
    const camera = new THREE.OrthographicCamera(-2, 2, 1.5, -1.5, 0, 10);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- RAYMARCHING SHADER ---
    const fragmentShader = `
        precision highp float;
        uniform vec2 uResolution;
        uniform float uTime; // Progress 0.0 to 1.0
        
        // --- MATH UTILS ---
        
        // Polynomial Smooth Minimum (blends shapes organically)
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }

        float sdSphere(vec3 p, float r) {
            return length(p) - r;
        }

        // Cylinder with finite height h and radius r
        float sdCappedCylinder(vec3 p, float h, float r) {
            vec2 d = abs(vec2(length(p.yz), p.x)) - vec2(r, h);
            return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
        }

        // Torus lying on the XY plane (before rotation)
        float sdTorus(vec3 p, vec2 t) {
            vec2 q = vec2(length(p.xz) - t.x, p.y);
            return length(q) - t.y;
        }

        // --- SCENE DEFINITION ---
        float map(vec3 p) {
            float t = uTime; 
            
            // 1. LEFT SPHERE (Fixed Position)
            // Center at x = -1.1 so its right edge is near origin
            vec3 pSphere = p - vec3(-1.1, 0.0, 0.0);
            float dSphere = sdSphere(pSphere, 1.0);

            // 2. RIGHT TORUS (Moving Left)
            // Start X: 1.8 (Far) -> End X: 1.3 (Separated from Sphere)
            // Note: Sphere radius 1.0 + Torus Ring radius 1.1 approx = 2.1 distance needed?
            // Let's tune end position to ensuring "Kissing" point at origin.
            float torusX = mix(1.8, 1.3, t);
            
            vec3 pTorus = p - vec3(torusX, 0.0, 0.0);
            
            // Rotate Torus to face camera (like a wheel standing up)
            // Rotate 90 deg on X, then slight tilt on Y for 3D depth
            float angleX = 1.5708; 
            float ca = cos(angleX); float sa = sin(angleX);
            pTorus.yz = mat2(ca, -sa, sa, ca) * pTorus.yz;
            
            // Slight Y-tilt to see the hole better
            float angleY = 0.3; 
            float cy = cos(angleY); float sy = sin(angleY);
            pTorus.xz = mat2(cy, -sy, sy, cy) * pTorus.xz;

            // Torus Collapse Logic:
            // Tube thickness shrinks (0.4 -> 0.05)
            float tubeThick = mix(0.4, 0.05, t);
            float dTorus = sdTorus(pTorus, vec2(1.1, tubeThick));

            // 3. NECK (Connecting, shrinking, moving)
            // Position: Exact midpoint between Sphere Center and Torus Center
            float midX = (-1.1 + torusX) * 0.5;
            vec3 pNeck = p - vec3(midX, 0.0, 0.0);
            
            // Radius Logic: Shrinks to zero (singularity)
            // We use a negative end value (-0.2) so it completely vanishes mathematically
            float neckRadius = mix(0.45, -0.2, t);
            
            // Length Logic:
            // Distance between centers = torusX - (-1.1)
            // We want cylinder to stop SHORT of the centers to avoid penetrating the hole.
            // Half-distance
            float halfDist = (torusX - (-1.1)) * 0.5;
            
            // Height of cylinder (h) should be slightly less than halfDist 
            // to allow the 'smin' to bridge the gap without the cylinder 
            // physically poking into the donut hole.
            // As t increases, we shorten it faster to simulate the neck pinching off longitudinally too.
            float neckHeight = halfDist - 0.8 - (0.4 * t); 
            
            float dNeck = sdCappedCylinder(pNeck, neckHeight, neckRadius);

            // --- BLENDING ---
            // Blend Sphere + Neck
            float d = smin(dSphere, dNeck, 0.5);
            
            // Blend Result + Torus
            // We use a slightly tighter blend (0.4) for the torus connection
            d = smin(d, dTorus, 0.4);

            return d;
        }

        // --- NORMALS ---
        vec3 calcNormal(vec3 p) {
            const float h = 0.0001;
            const vec2 k = vec2(1, -1);
            return normalize(
                k.xyy * map(p + k.xyy * h) +
                k.yyx * map(p + k.yyx * h) +
                k.yxy * map(p + k.yxy * h) +
                k.xxx * map(p + k.xxx * h)
            );
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * uResolution.xy) / uResolution.y;

            // Camera (Flat diagrammatic view)
            vec3 ro = vec3(0.0, 0.0, 5.0); 
            vec3 rd = normalize(vec3(uv, -1.0));

            // Raymarching
            float tVal = 0.0;
            float d = 0.0;
            vec3 p;
            bool hit = false;

            for(int i = 0; i < 90; i++) {
                p = ro + rd * tVal;
                d = map(p);
                if(d < 0.001) { hit = true; break; }
                if(tVal > 10.0) break;
                tVal += d;
            }

            // Render
            vec3 color = vec3(1.0); // Background White

            if(hit) {
                vec3 normal = calcNormal(p);
                vec3 lightPos = vec3(2.0, 4.0, 5.0);
                vec3 lightDir = normalize(lightPos);
                
                // Soft directional lighting
                float diff = max(dot(normal, lightDir), 0.0);
                float amb = 0.6 + 0.4 * normal.y; // Skyfill
                float rim = pow(1.0 + dot(rd, normal), 4.0); // Edge highlight

                // Material Color (Blue)
                vec3 surfColor = vec3(0.3, 0.5, 0.9);
                
                // Darken crevices (Pseudo-AO based on normal y)
                // This helps see the shape of the neck connection
                surfColor *= (0.8 + 0.2*normal.y);

                color = surfColor * (diff * 0.6 + amb * 0.3) + rim * 0.1;
            }

            // Gamma
            color = pow(color, vec3(0.4545));
            gl_FragColor = vec4(color, 1.0);
        }
    `;

    // --- MESH & MATERIAL ---
    const planeGeo = new THREE.PlaneGeometry(2, 2);
    const planeMat = new THREE.ShaderMaterial({
        fragmentShader: fragmentShader,
        vertexShader: `void main() { gl_Position = vec4(position, 1.0); }`,
        uniforms: {
            uResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
            uTime: { value: 0.0 }
        }
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    scene.add(plane);

    // --- ANIMATION LOOP ---
    const CONFIG = {
        frames: 240, // 8 seconds
        fps: 30
    };
    
    let currentFrame = 0;
    let isRecording = false;

    // Capture settings
    const capturer = new CCapture({ 
        format: 'webm', 
        framerate: CONFIG.fps,
        name: 'geometric_singularity'
    });

    // Ease in-out for smooth movement
    function easeInOutCubic(x) {
        return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
    }

    function animate() {
        requestAnimationFrame(animate);

        let progress = 0;
        
        if (isRecording) {
            progress = currentFrame / CONFIG.frames;
            if (progress > 1.0) {
                finishRecording();
                return;
            }
            document.getElementById('status').innerText = `Rendering: ${Math.round(progress * 100)}%`;
        } else {
            // Idle preview: Show frame 0
            progress = 0.0;
        }

        // Apply easing to the time uniform
        planeMat.uniforms.uTime.value = easeInOutCubic(progress);

        renderer.render(scene, camera);

        if (isRecording) {
            capturer.capture(renderer.domElement);
            currentFrame++;
        }
    }

    function startRecording() {
        isRecording = true;
        currentFrame = 0;
        document.getElementById('btn-record').disabled = true;
        capturer.start();
    }

    function finishRecording() {
        isRecording = false;
        capturer.stop();
        capturer.save();
        document.getElementById('status').innerText = "Complete. Downloading file.";
        document.getElementById('btn-record').disabled = false;
        // Reset
        planeMat.uniforms.uTime.value = 0.0;
        renderer.render(scene, camera);
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        planeMat.uniforms.uResolution.value.set(window.innerWidth, window.innerHeight);
        
        // Adjust aspect ratio correction in camera (though shader handles UVs)
        const aspect = window.innerWidth / window.innerHeight;
        // We actually handle aspect in shader via uResolution, but updating camera is good practice
        camera.left = -2 * aspect;
        camera.right = 2 * aspect;
        camera.updateProjectionMatrix();
    });

    animate();

</script>
</body>
</html>