<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Ricci Flow Sphere - V5 Final</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            /* Darker, muted background for better contrast with the matte sphere */
            background: radial-gradient(circle at center, #1c2e36 0%, #050505 100%);
            font-family: 'Segoe UI', sans-serif; 
        }
        canvas { display: block; cursor: grab; }
        canvas:active { cursor: grabbing; }
        
        #video-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border: 1px solid #008cba; /* Thinner, dimmer border */
            border-radius: 8px;
            overflow: hidden;
            z-index: 10;
            transform: scaleX(-1);
            opacity: 0.6; /* Less distracting */
        }
        #input-video { width: 100%; height: 100%; object-fit: cover; }
        
        #ui-layer {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 600px;
            text-align: center;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: none;
        }

        #mode-indicator {
            background: rgba(0, 0, 0, 0.6);
            color: #ccc;
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid #333;
            font-size: 14px;
            letter-spacing: 1px;
            margin-bottom: 10px;
            font-weight: 500;
        }

        button {
            pointer-events: auto;
            /* Muted Teal Button */
            background: linear-gradient(135deg, #008cba, #005f7f);
            border: none;
            border-radius: 6px;
            padding: 12px 30px;
            color: #eee;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s, filter 0.2s;
            align-self: center;
        }
        button:hover { filter: brightness(1.1); transform: scale(1.01); }
        button:active { transform: scale(0.98); }

        #progress-container {
            width: 100%;
            height: 4px;
            background: #222;
            border-radius: 2px;
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background: #008cba;
            transition: width 0.1s linear;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            pointer-events: none;
            line-height: 1.6;
        }
        .key { color: #00aecb; font-weight: 600; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="video-container">
        <video id="input-video"></video>
    </div>

    <div id="instructions">
        <h3>Controls</h3>
        <p><span class="key">Pinch (Index+Thumb)</span> : Sculpt</p>
        <p><span class="key">Mouse Drag</span> : Rotate View</p>
    </div>

    <div id="ui-layer">
        <div id="mode-indicator">Waiting for hand...</div>
        
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>

        <button id="ricci-btn">Start Ricci Flow Smoothing</button>
    </div>

<script>
    // --- 1. THREE.JS SCENE SETUP ---
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- SOFTER LIGHTING (Requested) ---
    // Ambient light reduced significantly for contrast
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
    scene.add(ambientLight);
    
    // Directional light dimmed
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 5, 5);
    scene.add(dirLight);
    
    // Fill light for the blue tint, also dimmed
    const blueLight = new THREE.PointLight(0x008cba, 0.8, 40);
    blueLight.position.set(-5, 2, 5);
    scene.add(blueLight);

    // --- SPHERE SETUP ---
    const originalRadius = 1.8;
    const geometry = new THREE.IcosahedronGeometry(originalRadius, 24); // Higher detail for smoother matte look
    
    // --- MATTE MATERIAL (Requested) ---
    const material = new THREE.MeshPhysicalMaterial({
        color: 0x00aecb,      // The teal color you liked
        roughness: 0.7,       // High roughness = Matte (Clay/Chalk look)
        metalness: 0.1,       // Very low metalness
        clearcoat: 0.0,       // No shiny coating
        flatShading: false,
    });

    const wireGeo = new THREE.WireframeGeometry(geometry);
    const wireMat = new THREE.LineBasicMaterial({ color: 0x004455, transparent: true, opacity: 0.05 });
    const wireframe = new THREE.LineSegments(wireGeo, wireMat);
    
    const sphere = new THREE.Mesh(geometry, material);
    sphere.add(wireframe);
    scene.add(sphere);

    // Cursor
    const cursorGeo = new THREE.SphereGeometry(0.12, 16, 16);
    const cursorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
    const cursor = new THREE.Mesh(cursorGeo, cursorMat);
    scene.add(cursor);
    cursor.visible = false;

    // --- 2. STATE VARIABLES ---
    let handState = 'none'; 
    let prevHandX = 0;
    let prevHandY = 0;
    
    // Rotation physics
    let targetRotationX = 0;
    let targetRotationY = 0;
    
    // Smoothing
    let isFlowing = false;
    let initialError = 0;

    // Mouse State
    let isMouseDown = false;
    let mouseX = 0;
    let mouseY = 0;

    // --- 3. MOUSE CONTROL LOGIC ---
    window.addEventListener('mousedown', (e) => {
        if(e.target.tagName !== 'BUTTON') {
            isMouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }
    });

    window.addEventListener('mouseup', () => { isMouseDown = false; });
    window.addEventListener('mouseleave', () => { isMouseDown = false; });

    window.addEventListener('mousemove', (e) => {
        if (!isMouseDown) return;

        const dx = e.clientX - mouseX;
        const dy = e.clientY - mouseY;

        // Rotation Sensitivity
        const speed = 0.005;

        // Mouse Drag rotates view
        targetRotationY += dx * speed;
        targetRotationX += dy * speed;

        mouseX = e.clientX;
        mouseY = e.clientY;
        
        modeIndicator.innerText = "ROTATING (Mouse)";
        modeIndicator.style.borderColor = "#00aecb";
    });


    // --- 4. MEDIAPIPE LOGIC ---
    const videoElement = document.getElementById('input-video');
    const modeIndicator = document.getElementById('mode-indicator');

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const indexTip = landmarks[8];
            const thumbTip = landmarks[4];
            
            const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);

            const rawX = 1 - ((indexTip.x + thumbTip.x) / 2); 
            const rawY = 1 - ((indexTip.y + thumbTip.y) / 2);

            updateCursor(rawX, rawY);

            // SIMPLIFIED LOGIC: Pinch to sculpt, otherwise just idle cursor.
            // Rotation is now Mouse-only (or external logic).
            
            if (pinchDist < 0.05) {
                setMode('sculpt');
                deformSphere();
            } else if (!isMouseDown) {
                setMode('idle');
            }
            
            prevHandX = rawX;
            prevHandY = rawY;

        } else {
            // No hand detected
            if(!isMouseDown) {
                setMode('none');
                cursor.visible = false;
            }
        }
    }

    function setMode(mode) {
        if(isMouseDown && mode !== 'sculpt') return; 

        handState = mode;
        if (mode === 'sculpt') {
            cursor.material.color.set(0xffaa00); 
            modeIndicator.innerText = "SCULPTING (Pinch)";
            modeIndicator.style.borderColor = "#ffaa00";
            cursor.visible = true;
        } else if (mode === 'idle') {
            cursor.material.color.set(0x888888);
            modeIndicator.innerText = "Ready to Sculpt";
            modeIndicator.style.borderColor = "#444";
            cursor.visible = true;
        } else {
            modeIndicator.innerText = "Show Hand or Drag Mouse";
            modeIndicator.style.borderColor = "#333";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 320, height: 240
    });
    cameraUtils.start();

    // --- 5. INTERACTION FUNCTIONS ---

    function updateCursor(nx, ny) {
        const ndcX = (nx * 2) - 1;
        const ndcY = (ny * 2) - 1;
        const visibleHeight = 2 * Math.tan((camera.fov * Math.PI / 180) / 2) * Math.abs(camera.position.z - 1.8);
        const visibleWidth = visibleHeight * camera.aspect;
        cursor.position.x = ndcX * (visibleWidth / 2);
        cursor.position.y = ndcY * (visibleHeight / 2);
        cursor.position.z = 1.8; 
    }

    function deformSphere() {
        if (handState !== 'sculpt') return;
        if (isFlowing) stopRicciFlow();

        const positions = sphere.geometry.attributes.position;
        const v3 = new THREE.Vector3();
        const localCursor = cursor.position.clone();
        sphere.worldToLocal(localCursor);

        const brushRadius = 0.7;
        const strength = 0.09; 

        let modified = false;
        for (let i = 0; i < positions.count; i++) {
            v3.fromBufferAttribute(positions, i);
            const dist = v3.distanceTo(localCursor);
            if (dist < brushRadius) {
                const influence = Math.pow((1 - dist / brushRadius), 2); 
                const dir = new THREE.Vector3().subVectors(localCursor, v3).normalize();
                positions.setXYZ(i, v3.x + dir.x * strength * influence, v3.y + dir.y * strength * influence, v3.z + dir.z * strength * influence);
                modified = true;
            }
        }
        if (modified) {
            positions.needsUpdate = true;
            sphere.geometry.computeVertexNormals();
        }
    }

    // --- 6. RICCI FLOW LOGIC ---

    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.getElementById('progress-container');
    const ricciBtn = document.getElementById('ricci-btn');

    ricciBtn.addEventListener('click', () => {
        isFlowing ? stopRicciFlow() : startRicciFlow();
    });

    function startRicciFlow() {
        isFlowing = true;
        ricciBtn.innerText = "Stop Smoothing";
        progressContainer.style.opacity = "1";
        initialError = calculateTotalError();
        if (initialError < 0.1) initialError = 1; 
    }

    function stopRicciFlow() {
        isFlowing = false;
        ricciBtn.innerText = "Start Ricci Flow Smoothing";
        progressContainer.style.opacity = "0";
        setTimeout(() => { progressBar.style.width = "0%"; }, 500);
    }

    function calculateTotalError() {
        const positions = sphere.geometry.attributes.position;
        const v3 = new THREE.Vector3();
        let totalDiff = 0;
        for (let i = 0; i < positions.count; i++) {
            v3.fromBufferAttribute(positions, i);
            totalDiff += Math.abs(v3.length() - originalRadius);
        }
        return totalDiff;
    }

    function updateRicciFlow() {
        const positions = sphere.geometry.attributes.position;
        const v3 = new THREE.Vector3();
        const flowRate = 0.02; 
        let currentTotalError = 0;

        for (let i = 0; i < positions.count; i++) {
            v3.fromBufferAttribute(positions, i);
            const dist = v3.length();
            const diff = dist - originalRadius;
            currentTotalError += Math.abs(diff);

            if (Math.abs(diff) > 0.001) {
                const scaleFactor = 1 - (flowRate * (dist - originalRadius) / dist);
                positions.setXYZ(i, v3.x * scaleFactor, v3.y * scaleFactor, v3.z * scaleFactor);
            }
        }
        positions.needsUpdate = true;
        sphere.geometry.computeVertexNormals();

        let percent = 100 - ((currentTotalError / initialError) * 100);
        progressBar.style.width = Math.max(0, Math.min(100, percent)) + "%";

        if (currentTotalError < 0.1) stopRicciFlow();
    }


    // --- 7. RENDER LOOP ---
    function animate() {
        requestAnimationFrame(animate);
        
        // Physics for rotation (Mouse only now)
        sphere.rotation.y += (targetRotationY - sphere.rotation.y) * 0.1;
        sphere.rotation.x += (targetRotationX - sphere.rotation.x) * 0.1;

        if (isFlowing) updateRicciFlow();
        
        wireframe.material.opacity = 0.03 + Math.sin(Date.now() * 0.001) * 0.02;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    animate();
</script>
</body>
</html>